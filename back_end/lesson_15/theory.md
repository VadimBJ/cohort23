## Структура проекта

* `src` - файлы исходного кода
  * `main`
    * `java`
      * `controllers` - классы, которые обрабатывают HTTP-запросы от клиента и вызывают методы сервисов, также возвращают HTTP-ответы 
        * `api` - интерфейсы, которые содержат документацию Swagger и Spring Web-аннотации (чтобы не засорять основной контроллер)
      * `services` - содержат бизнес-логику, взаимодействуют с несколькими репозиториями. Содержат "саму программу"
      * `repostories` - интерфейсы и реализации (опционально) логики для работы с хранилищем данных (CRUD), в нашем случае - интерфейсы-потомки `JpaRepository`
      * `models` - модели предметной области. Классы, которые соответствуют таблицам в БД. Содержат данные, с которыми мы работаем
      * `validation` - классы для реализации валидации в нашей системе (проверка корректности входящих JSON-ов)
        * `dto` - описывает данные об ошибках валидации, которые мы будем показывать клиенту
        * `handler`
          * `ValidationExceptionHandler` - преобразует ошибки валидации, которые возникают в приложении, в формат DTO
        * `constraints` - собственные аннотации для валидации
        * `validators` - собственные валидаторы для собственных аннотаций
      * `dto` - Data Transfer Object (объект передачи данных), описывает данные, которые передаются между клиентом и сервером в формате JSON
      * `exceptions` - наши собственные классы исключений, которые выбрасываются в сервис-слое и для них указаны статусы ответов.
    * `resources`
      * `http` - папка с http-файлами (для отправки запросов, тестирования)
        * `users.http` - файл с запросами, начинающимися с `/api/users`
        * `articles.http` - файл с запросами, начинающимися с `/api/articles`
      * `application.properties` - файл с настройками приложения
        * `spring.datasource` - настройки подключения к БД
        * `spring.h2` - настройки для работы с БД типа H2
        * `spring.jpa` - настройки для Hibernate
    * `RestApiApplication` - точка входа в приложение, запускает ваше SpringBoot-приложение
  * `test`
* `target` - скомпилированные файлы, ресурсы
* `pom.xml` - файл Maven-проекта, содержит координаты проекта
  * `<dependencies>` - сторонние зависимости, который Maven выгружает из интернета по их координатам
    * `h2` - для работы с базой данных H2
    * `spring-boot-starter-data-jpa` - для работы с `JpaRepository`, автоматически подтягиваются:
      * `hibernate-core` - движок для ORM (генерации SQL на основе объектов и обратно)
      * `jakarta-persistence-api` - JPA, набор аннотаций для работы ORM в Java (стандарт)
    * `springdoc-openapi-ui` - для работы Swagger (документация API)
    * `hamcrest-all` - для работы метода `is` в тестах
    * `spring-boot-starter-test` - для работы `MockMvc` (компонент для отправки запросов на собственный сервер), нужен для тестов
    * `lombok` - для работы с аннотациями `@Data`, `@AllArgsConstructor` и т.д.
    * `spring-boot-starter-validation` - используется для реализации валидации в проекте, автоматически подтягиваются:
      * `jakarta-validation-api` - содержит аннотации валидации - `@NotNull`, `@Email` и т.д.
      * `hibernate-validator` - реализация валидации по аннотациям `jakarta-validation-api`
    * `spring-boot-starter-web` - для реализации контроллеров и в целом для взаимодействия по HTTP, также подтягиваются:
      * `jackson-databind/core` - библиотеки для конвертации Java-объектов в JSON и обратно
  * `<parent>`
    * `spring-boot-starter-parent` - содержит базовые зависимости для `Spring Boot` - автоконфигурации, также подтягиваются:
      * `spring-context` - содержит `ApplicationContext`

![image](https://raw.githubusercontent.com/ait-tr/cohort23/main/back_end/lesson_15/img/1.png)

## Технологии

### JPA/jakarta-validation-api + Hibernate

* JPA - интерфейс (аннотации)
* Hibernate - реализация (обработка аннотаций и генерация SQL)

* `@Entity` - для того, чтобы ORM-фреймворк (Hibernate) могли связать класс с таблицей в БД
* `@Table(name = "account")` - чтобы задать свое имя для таблицы, созданной на основе класса. По умолчанию используется название класса.
* `@Id` - показываем Hibernate, где у нас находится первичный ключ
* `@GeneratedValue(strategy = GenerationType.IDENTITY)` - обозначаем, что первичный ключ генерируется самой базой данных
* `@Enumerated(value = EnumType.STRING)` - для хранения enum-значений как строк в БД
* `@ManyToOne` - для обозначения связи "Многие-к-одному", используется вместе с `@JoinColumn`
* `@JoinColumn(name = "about_id")` - говорит о необходимости создания внешнего ключа с названием `about_id` на другую таблицу
* `@OneToMany(mappedBy = "about")` - для обозначения связи "Один-ко-многим", указываем название поля в подклассе.

### Spring Data JPA

* model == entity == модель == сущность == persistence object

* `JpaRepository<T, ID>` - интерфейс, который содержит базовый набор операций:
  * `void save(T entity)` - сохранение/обновление сущности
  * `Optional<T> findById(ID id)` - получение сущности по id
  * `List<T> findAll()` - получение списка сущностей
* Данные методы реализовывать не нужно, Spring Data JPA реализует их за вас и отдаст Hibernate

### Spring Web

* `@RequestMapping("/api/users")` - означает, что методы контроллера будут обрабатывать запросы, начинающиеся с URL - `/api/users`

* Аннотации, которые мы вешаем на методы
  * означают, что метод будет обрабатывать определенный тип HTTP-запроса по определенному URL
    * `@PostMapping` - метод обрабатывает POST-запрос
    * `@GetMapping` - метод обрабатывает GET-запрос
    * `@DeleteMapping("/{user-id}")` - метод обрабатывает DELETE-запрос с указанием ID в URL, например - `DELETE /api/users/2`
    * `@PutMapping("/{user-id}")` - метод обрабатывает PUT-запрос с указанием ID в URL, например - `DELETE /api/users/2`
  * означают, что метод будет возвращать определенный HTTP статус:
    * `@ResponseStatus(HttpStatus.CREATED)` - метод вернет статус `201 CREATED`
  
* Аннотации, которые мы вешаем на параметры методов:
  * `@RequestBody NewUserDto newUser` - означает, что `newUser` мы возьмем из тела запроса (после его конвертации из JSON)
  * `@PathVariable("user-id") Long userId` - означает, что значение `userId` мы возьмем из части URL, например `DELETE /api/users/{user-id}`. Значит, при запросе `DELETE /api/users/2` в `userId` будет лежать `2`  
  * `@RequestParam("size") int size` - означает, что значение `size` мы возьмем из параметров запроса (часть URL, которая начинается с `?`), например для `GET /users?size=10`, в `size` будет лежать `10`

* Дополнительно:
  * `@ResponseBody` - вешаем на метод, данная аннотация показывает, что результат работы метода должен быть сконвертирован в JSON и отправлен в качестве тела ответа.
  * Мы не указываем эту аннотацию, потому что она проставляется автоматически для `@RestController`

* `ResponseEntity<T>` - класс, который позволяет удобно возвращать тело ответа вместе со статусом (и другой полезной информацией) 

### Swagger

* `@Tags` - позволяет указать блок, в котором будут отображаться методы контроллера
* `@Operation` - можно дать описание конкретного метода
* `@ApiResponses` - позволяет перечислить все варианты ответов на данный запрос, можно статус ответа и тело, которое будет получено
* `@Schema` - позволяет дать описание конкретной DTO (JSON-у)
* `@Parameter` - позволяет задокументировать параметр запроса (либо `@PathVariable`, либо `@RequestParam`)

### Java Validation API/javax.validation/jakarta.validation + Hibernate Validator

* Набор аннотаций и интерфейсов для реализации валидации

* `@Valid` - вешаем на параметр метода (как правило - контроллера), чтобы валидатор проверил этот объект, прежде, чем он пойдет дальше.

* Аннотации для проверок:
  * `@NotNull`: Поле не должно быть null.
  * `@NotBlank`: Строка не должна быть пустой или состоять только из пробелов.
  * `@NotEmpty`: Коллекция или массив не должны быть пустыми.
  * `@Min` : Значение поля должно быть больше или равно указанной минимальной границе.
  * `@Max`: Значение поля должно быть меньше или равно указанной максимальной границе.
  * `@Size` : Размер коллекции или строки должен находиться в определенных пределах (минимальный и максимальный размер).
  * `@Length` : (В Hibernate) Длина строки или массива должна быть в определенных пределах (минимальный и максимальный размер).

* `ConstraintValidator<ANNOTATION, TYPE>` - интерфейс, в котором указывается аннотация, которую валидируем и тип поля, которое хотим проверить

### Spring 

* `@Service` - позволяет сделать бин на основе класса, который помечен этой аннотацией.
* `@RestController` - в этом плане работает так же.