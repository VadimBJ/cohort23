# Lesson 06 - 14.07.2023

## 01. Клиент-серверное взаимодействие и проблемы MVC

* Клиентское приложение (клиент) - приложение, которое может взаимодействовать с серверным приложением.
* Как правило, клиентское приложение устанавливается на компьютер пользователя

* Серверное приложение (сервер) - приложение, которое взаимодействует со множеством клиентов.
* Серверное приложение устанавливается на выделенное "железо" - сервер. К этому серверу у всех есть доступ.
* Backend-разработчики как раз занимаются созданием серверных приложений.

* Клиент посылает запросы на сервер, а сервер отвечает
* Это происходит в рамках протокола HTTP

* Вспомним - MVC?
* MVC - это подход, когда серверное приложение содержит готовые HTML-страницы и отдает их браузеру.
* Вы создаете шаблоны (templates) они заполняются данными серверным приложением.
* Почему такой подход сейчас не используется?
* Потому что типов клиентов очень много и не всем нужны готовые HTML-страницы
* Сервер теперь будет принимать данные и отдавать данные, а как уже это будет выглядеть - решает клиентское приложение.
* Например, есть страница с пользователями на сайте, есть экран "пользователи" в мобильном приложении
* Сервер не будет думать, как это должно выглядеть, он просто отдаст список пользователей

## 02. Архитектура

### Models

* models - модели предметной области
* Сущности (Entities), с которыми мы работаем
* Они не содержат сложного кода, как правило - только поля.

### Controllers

* Классы, которые отвечают за взаимодействие по HTTP

### Services

* Классы, отвечающие за бизнес-логику
* Бизнес-логика - это алгоритмы вашего приложения, которые отвечают необходимым потребностям
* В сервисах реализуют функционал, который важен для вашего приложения


### Зачем мы все это делаем?

* Зачем писать код "красиво"?
  * Код чаще читают, чем пишут. - код нужно дописывать, дорабатывать, исправлять ошибки.
  * Поэтому есть стандарты.

* Что значит "красиво"?
  * Адекватные названия переменных, классов, методов - они полностью отражают суть того, для чего они нужны.
  * Форматирование кода - адекватные отступы, отсутствие пустых строк, пробелы в нужных местах
  * Соблюдение архитектуры

* Зачем нужна архитектура?
  * Архитектура повышает читаемость кода и делает его "гибким" - готовым к изменениям и масштабированию
  * Мы должны разделять код на "слои", каждый слой должен работать "независимо" от другого.

* Зачем разделять на контроллеры и сервисы?
  * Потому что у вас может измениться способ общения с клиентом, вместо HTTP может быть GRPC, либо WebSockets и т.д.
  * Чтобы иметь возможность безболезненно "с минимальным воздействием на код" изменить способ общения с клиентом - логику от общения разделяем

* Изменение кода сервиса в зависимости от способа хранения данных (либо файл, либо список) - это очень плохо!!!
* Сервис вообще не должен знать о том, как хранятся данные (тогда код будет более гибкий)

## 03. JSON

* Java Script Object Notation - формат обмена данными. Имеет определенную структуру:

```json
[
  {
    "id": 1,
    "model": "BMW",
    "color": "Black"
  },
  {
    "id": 2,
    "model": "Audi",
    "color": "Red"
  },
  {
    "id": 3,
    "model": "Mercedes",
    "color": "Silver"
  },
  {
    "id": 4,
    "model": "Ford",
    "color": "Blue"
  }
]
```

* `[ ... ]` - массив (строк, чисел, других объектов)
* `{ ... }` - JSON-объект
* `key : value` - каждое поле объекта - пара ключ-значение
* В качестве значения (value) - число, логическое значение, строка, массив, другой объект 
* Формат JSON - наиболее распространенный формат обмена данными между приложениями. 

### Как это сработало в нашем приложении?

* ` @ResponseBody` - если мы ставим такую аннотацию над методом в классе-контроллере, то Spring будет понимать, что:
  * Вы возвращаете не название `view`, а тело ответа (данные), которое нужно передать клиенту
  * Таким образом, Spring использует специальный "преобразователь" (конвертер, serializer), который преобразует Java-объекты в JSON
* Конвертер `Java в JSON` и `JSON в Java` называется `Jackson`