# Lesson 07 - 19.07.2023

## 01. Spring

* Центральное понятие Spring - IoC-контейнер (контейнер бинов, Spring Context)
* Контейнер бинов - содержит все бины с их связями
* Бин - компонент, какой-то объект, бин имеет свой идентификатор (id) и тип, на основе которого он создан.
* IoC/DI - Inversion of Control/Dependency Injection - принцип, когда создание и связывание компонентов мы выносим в отдельные модули
* Эти модули отвечают за конфигурацию приложения (в данном случае, это `ApplicationConfig`)
* `Inject` - инъекция, это когда бин из контейнера подставляется в другой бин или параметр, поле и т.д.

* `ApplicationContext` - интерфейс, который описывает поведение `контейнера бинов`
* `AnnotationConfigApplicationContext` - реализация контейнера бинов на основе аннотаций.
* `getBean` - метод для получения бина из контейнера. Если бин подходящего типа один - проблем нет, если более одного - нужно указать его id
* `@Autowired` - данную аннотацию можно вешать на поле, конструктор или сеттер. Благодаря этой аннотации Spring делает inject какого-либо бина, подходящего по типу.
* `@ComponentScan` - вешаем данную аннотацию на класс-конфигурации. В ней указываем пакеты, где нужно искать классы с `@Component`

## 02. Способы объявления бинов

### 1. Аннотация @Bean

* С помощью этой аннотации мы указываем фабричный метод, создающий какой-либо бин
* Название метода - id бина
* Если нашему бину нужны какие-то другие бины, их можно перечислить в параметрах метода с аннотацией `@Bean`
* Если кандидатов несколько - то используем аннотацию `@Qualifier`, где указываем идентификатор нужного бина

### 2. Аннотация @Component

* Данной аннотацией помечаем класс, на основе которого будет создан бин
* По умолчанию, id этого бина - название класса, только с маленькой буквы. Но можно назначить свой id.
* А можно ли все-таки некоторые "сложные" бины тоже объявить как компонент?

## 03. Работа с Properties-файлами

* Некоторые свойства приложения можно выносить в отдельный файл `properties`
* Тогда необходимо в конфигурационном файле указать путь к этому файлу через `@PropertySource` - `@PropertySource(value = "classpath:application.properties")`
* В самих компонентах просто используем аннотацию `@Value` с указанием названия свойства

### Резюмируя

* Получили такой код, где мы не думаем о связывании и создании объектов, мы просто пользуемся тем, что дает нам Spring
* Он сам настраивает наше приложение

### Как бывает в реальном проекте?

* Как правило, у каждого бина только одна реализация, поэтому можно не использовать `@Qualifier`
* Можно не использовать `@Autowired`
* Вместо аннотации `@Component` можно использовать синонимы, чтобы улучшить понимание бина.
  * `@Service`
  * `@Repository`
* Можно использовать lombok для сокращения количества кода

### Повторение

```
1. Приложение может состоять из нескольких разных компонентов
   - сервисы
   - репозитории
   - валидаторы
2. Каждый компонент может иметь несколько реализаций
3. Чтобы можно было заменять реализации, мы используем интерфейсы в качестве зависимостей
4. Мы бы хотели как-то упростить себе жизнь (но по факту усложнили, для того чтобы понять, а как упростить потом)
    - Ввели понятие Spring
    - Поняли, что в Spring есть какой-то контейнер
    - В этом контейнере какие-то бины с какими-то id
    - Поняли, что бин - это просто объект определенного класса, а id - это обычная строка (название компонента)
5. Далее, изучили всю схему чуть подробнее:
    - Мы поняли, что бины нужно ОБЪЯВЛЯТЬ
    - При объявлении бина следует указать его тип и его id
    - Есть первый способ - аннотация @Bean
    - В этом случае название метода, который создает бин и есть его id
    - А тип бина - это тип объекта, который возвращает метод
    - Spring пробегает по классу с @Bean-ами и создает все бины
    - А что с зависимостями? Ведь например UsersService зависит аж от валидаторов и репозиториев
    - Тут нам помогает Spring
    - У нас у в контейнере уже есть бины для валидаторов и репозиториев
    - Нужно просто создать метод @Bean для сервиса и в него передать уже созданные бины
    - Внутри метода создали сам сервис с уже готовыми бинами
    - При этом важно учесть, что передаем мы интерфейс, а нужна конкретная реализация
    - При этом у одного интерфейса может быть несколько реализаций бинов
    - Но у каждой реализации есть свой id, его то и нужно указать с помощью @Qualifier
6. Попробуем теперь действительно упростить жизнь, минимизируя количество кода
    - Некоторые "простые" бины (те, которое создаются просто через new без чего-то еще)
    - мы можем объявить через `@Component`, без создания отдельного метода
    - мы также вынесли в `@Component` usersService, как поступить с его зависимостями?
    - можно просто указать `@Autowired` (автосвязывание) и Spring сам подставит нужные бины в конструктор
    - Но нужно также указать `@Qualifier`, чтобы не было коллизий (несколько бинов на один инджект)
7. На что обратить внимание:
    - в ApplicationConfiguration нужно поставить `@ComponentScan` и указать пакеты, где находятся наши `@Component`
    - Название бинов, которые помечены `@Component` - это название классов с маленькой буквы
    - Название бина можно поменять, просто указав его в параметрах аннотации
```